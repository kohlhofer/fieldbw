<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lorenz Attractor SVG Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      font-weight: 300;
      margin-bottom: 20px;
      font-size: 24px;
    }
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    label {
      font-size: 12px;
      color: #888;
    }
    input[type="range"] {
      width: 120px;
    }
    button {
      background: #fff;
      color: #000;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 14px;
      transition: opacity 0.2s;
    }
    button:hover { opacity: 0.8; }
    .svg-container {
      background: #000;
      border: 1px solid #333;
      margin-bottom: 20px;
    }
    svg {
      display: block;
    }
    .info {
      font-size: 12px;
      color: #666;
      text-align: center;
      max-width: 500px;
    }
  </style>
</head>
<body>
  <h1>Lorenz Attractor</h1>

  <div class="controls">
    <div class="control-group">
      <label>Rotate X: <span id="rxVal">0</span>°</label>
      <input type="range" id="rotateX" min="0" max="360" value="20">
    </div>
    <div class="control-group">
      <label>Rotate Y: <span id="ryVal">0</span>°</label>
      <input type="range" id="rotateY" min="0" max="360" value="0">
    </div>
    <div class="control-group">
      <label>Rotate Z: <span id="rzVal">0</span>°</label>
      <input type="range" id="rotateZ" min="0" max="360" value="0">
    </div>
    <div class="control-group">
      <label>Iterations: <span id="iterVal">2000</span></label>
      <input type="range" id="iterations" min="10" max="10000" step="10" value="2000">
    </div>
    <div class="control-group">
      <label>Min Stroke: <span id="swMinVal">0.5</span></label>
      <input type="range" id="strokeMin" min="0.1" max="5" step="0.1" value="0.5">
    </div>
    <div class="control-group">
      <label>Max Stroke: <span id="swMaxVal">8</span></label>
      <input type="range" id="strokeMax" min="1" max="20" step="0.5" value="8">
    </div>
    <div class="control-group">
      <label>Opacity: <span id="opVal">0.6</span></label>
      <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="0.6">
    </div>
    <div class="control-group">
      <label>FOV (wider &larr; &rarr; narrow): <span id="fovVal">4</span></label>
      <input type="range" id="fov" min="2" max="10" step="0.5" value="4">
    </div>
    <div class="control-group">
      <label>Scale: <span id="scaleVal">100</span>%</label>
      <input type="range" id="scale" min="30" max="150" step="5" value="100">
    </div>
    <button id="download">Download SVG</button>
  </div>

  <div class="svg-container">
    <svg id="svg" width="512" height="512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="#000"/>
      <g id="attractor"></g>
    </svg>
  </div>

  <p class="info">
    The Lorenz attractor is the iconic butterfly-shaped chaotic system discovered by Edward Lorenz.
    Adjust rotation and parameters, then download the SVG for use as an app icon.
  </p>

  <script>
    // Lorenz attractor parameters
    const sigma = 10;
    const rho = 28;
    const beta = 8 / 3;
    const dt = 0.005;

    // Generate attractor points
    function generateAttractor(iterations) {
      const points = [];
      let x = 0.1, y = 0, z = 0;

      for (let i = 0; i < iterations; i++) {
        const dx = sigma * (y - x);
        const dy = x * (rho - z) - y;
        const dz = x * y - beta * z;

        x += dx * dt;
        y += dy * dt;
        z += dz * dt;

        // Skip initial transient
        if (i > 100) {
          // Scale down and center the Lorenz attractor
          points.push({ x: x / 15, y: y / 15, z: (z - 25) / 15 });
        }
      }
      return points;
    }

    // 3D rotation
    function rotatePoint(p, rx, ry, rz) {
      let { x, y, z } = p;

      // Rotate X
      const cosX = Math.cos(rx), sinX = Math.sin(rx);
      let y1 = y * cosX - z * sinX;
      let z1 = y * sinX + z * cosX;
      y = y1; z = z1;

      // Rotate Y
      const cosY = Math.cos(ry), sinY = Math.sin(ry);
      let x1 = x * cosY + z * sinY;
      let z2 = -x * sinY + z * cosY;
      x = x1; z = z2;

      // Rotate Z
      const cosZ = Math.cos(rz), sinZ = Math.sin(rz);
      let x2 = x * cosZ - y * sinZ;
      let y2 = x * sinZ + y * cosZ;
      x = x2; y = y2;

      return { x, y, z };
    }

    // Project to 2D with perspective and create SVG path
    function createSVGPath(points, rx, ry, rz, strokeMin, strokeMax, opacity, fov, userScale) {
      const size = 512;
      const scale = 120 * (userScale / 100);
      const cx = size / 2;
      const cy = size / 2;

      // Camera distance for perspective (smaller = wider lens, more foreshortening)
      const cameraZ = fov;

      // Rotate and project points with perspective
      const projected = points.map(p => {
        const rotated = rotatePoint(p, rx, ry, rz);
        const perspectiveFactor = cameraZ / (cameraZ - rotated.z);

        return {
          x: cx + rotated.x * scale * perspectiveFactor,
          y: cy - rotated.y * scale * perspectiveFactor
        };
      });

      // Create segments with stroke width tapering from thin to thick along the path
      const segmentCount = 80;
      const pointsPerSegment = Math.floor(projected.length / segmentCount);
      const paths = [];

      for (let s = 0; s < segmentCount; s++) {
        const startIdx = s * pointsPerSegment;
        const endIdx = Math.min(startIdx + pointsPerSegment + 1, projected.length);
        const segment = projected.slice(startIdx, endIdx);

        if (segment.length < 2) continue;

        // Progress along path (0 to 1)
        const progress = s / (segmentCount - 1);

        // Stroke width scales from min to max along the path
        const sw = strokeMin + (strokeMax - strokeMin) * progress;

        // Opacity can also taper slightly
        const op = opacity * (0.7 + progress * 0.3);

        // Create smooth bezier path
        let d = `M ${segment[0].x.toFixed(2)} ${segment[0].y.toFixed(2)}`;

        for (let i = 0; i < segment.length - 1; i++) {
          const p0 = segment[Math.max(0, i - 1)];
          const p1 = segment[i];
          const p2 = segment[i + 1];
          const p3 = segment[Math.min(segment.length - 1, i + 2)];

          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;

          d += ` C ${cp1x.toFixed(2)} ${cp1y.toFixed(2)}, ${cp2x.toFixed(2)} ${cp2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
        }

        paths.push(`<path d="${d}" fill="none" stroke="#fff" stroke-width="${sw.toFixed(2)}" stroke-opacity="${op.toFixed(2)}" stroke-linecap="round" stroke-linejoin="round"/>`);
      }

      return paths.join('\n      ');
    }

    // Render
    function render() {
      const iterations = parseInt(document.getElementById('iterations').value);
      const rx = parseFloat(document.getElementById('rotateX').value) * Math.PI / 180;
      const ry = parseFloat(document.getElementById('rotateY').value) * Math.PI / 180;
      const rz = parseFloat(document.getElementById('rotateZ').value) * Math.PI / 180;
      const strokeMin = parseFloat(document.getElementById('strokeMin').value);
      const strokeMax = parseFloat(document.getElementById('strokeMax').value);
      const opacity = parseFloat(document.getElementById('opacity').value);
      const fov = parseFloat(document.getElementById('fov').value);
      const userScale = parseFloat(document.getElementById('scale').value);

      // Update labels
      document.getElementById('rxVal').textContent = document.getElementById('rotateX').value;
      document.getElementById('ryVal').textContent = document.getElementById('rotateY').value;
      document.getElementById('rzVal').textContent = document.getElementById('rotateZ').value;
      document.getElementById('iterVal').textContent = iterations;
      document.getElementById('swMinVal').textContent = strokeMin;
      document.getElementById('swMaxVal').textContent = strokeMax;
      document.getElementById('opVal').textContent = opacity;
      document.getElementById('fovVal').textContent = fov;
      document.getElementById('scaleVal').textContent = userScale;

      const points = generateAttractor(iterations);
      const pathsHTML = createSVGPath(points, rx, ry, rz, strokeMin, strokeMax, opacity, fov, userScale);
      document.getElementById('attractor').innerHTML = pathsHTML;
    }

    // Download SVG
    function downloadSVG() {
      const svg = document.getElementById('svg');
      const svgData = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.href = url;
      link.download = 'lorenz-attractor.svg';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // Event listeners
    document.querySelectorAll('input[type="range"]').forEach(input => {
      input.addEventListener('input', render);
    });
    document.getElementById('download').addEventListener('click', downloadSVG);

    // Initial render
    render();
  </script>
</body>
</html>
